<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>zuka_etl.custom.operator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>zuka_etl.custom.operator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &#39;phongphamhong&#39;

# !/usr/bin/python
#
# Copyright 11/9/18 Phong Pham Hong &lt;phongbro1805@gmail.com&gt;
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# # set enviroment in dev mode

import datetime
import json
import time

import six
from airflow.api.common.experimental.trigger_dag import trigger_dag
from airflow.contrib.operators.spark_submit_operator import SparkSubmitOperator
from airflow.exceptions import AirflowTaskTimeout, AirflowException
from airflow.hooks.base_hook import BaseHook
from airflow.models import BaseOperator
from airflow.models.dagrun import DagRun
from airflow.operators.dagrun_operator import DagRunOrder
# from zuka_etl.log import logger
from airflow.operators.python_operator import PythonOperator
from airflow.utils import timezone
from airflow.utils.decorators import apply_defaults

from zuka_etl.log import logger
from zuka_etl.pipeline.process import Process
from zuka_etl.setting import Setting


class EtlOperator(PythonOperator):
    &#34;&#34;&#34;
    Process ETL pipeline

        Example:

            def ex(pipeline):
                pipeline.logger.info(&#34;This is extract function&#34;)
                pipeline.set_shipper(&#34;a&#34;, &#34;11&#34;)
                return 1

            def transform(pipeline, value):
                pipeline.logger.info(&#34;This is transform function&#34;)
                print(value)
                return value

            def load(pipeline, value):
                pipeline.logger.info(&#34;This is load function&#34;)
                print(value)
                pipeline.logger.info(pipeline.get_shipper(&#34;a&#34;))
                # save every thing you want

            EtlOperator(
                task_id=&#34;phong&#34;,
                extract=ex,
                transform=tras,
                load=load
            )
    &#34;&#34;&#34;

    @apply_defaults
    def __init__(
            self,
            extract,  # type: Callable
            transform=None,  # type: Callable
            load=None,  # type: Callable
            extract_kwargs=None,  # type: Optional[Dict]
            provide_context=False,  # type: bool
            templates_dict=None,  # type: Optional[Dict]
            templates_exts=None,  # type: Optional[Iterable[str]]
            *args,
            **kwargs
    ):
        super(EtlOperator, self).__init__(
            python_callable=extract,
            op_args=None,
            op_kwargs=None,
            provide_context=provide_context,
            templates_dict=templates_dict,
            templates_exts=templates_exts, *args, **kwargs)
        self.python_callable_object = self.build_pipeline(task_id=self.task_id,
                                                          extract=extract,
                                                          transform=transform,
                                                          load=load, additional_args=None,
                                                          additional_kwargs=extract_kwargs).run

    @staticmethod
    def build_pipeline(task_id, extract, transform, load, additional_args, additional_kwargs):
        return Process(task_id, extract=extract, transform=transform, load=load, additional_args=additional_args,
                       additional_kwargs=additional_kwargs)

    def execute(self, context):
        self.python_callable_object.dag_context = context
        self.python_callable = self.python_callable_object.run
        super(EtlOperator, self).execute(context=context)


class SparkSubmitOperator(SparkSubmitOperator):
    &#34;&#34;&#34;
    Process Submit

        Example:
            from zuka_etl.custom.operator import SparkSubmitOperator

            ZukaSubmitOperator(
                task_id=&#34;phong&#34;,
                java_class = &#34;&#34;,
                application = &#34;/home/projects/job.jar&#34;,
                dag = dag_config
            )

    This hook is a wrapper around the SparkSubmitOperator to kick off a spark-submit job.
    It requires that the &#34;spark-submit&#34; binary is in the PATH or the spark-home is set
    in the extra on the connection.

        Parameters:
            application: str, the application that submitted as a job,  either jar or 
                py file. (templated)
            conf: dict, arbitrary Spark configuration properties (templated)            
            conn_id: str, the connection id as configured in Airflow  administration. 
                When an invalid connection_id  is supplied, it will default to yarn.
            files: str, upload additional files to the executor running the job, 
                separated by a comma. Files will be placed in the working directory 
                of each executor.
                    For example, serialized objects. (templated)
            py_files: str, additional python files used by the job, can be .zip, .egg 
                or .py. (templated)
            jars: str, submit additional jars to upload and place them in executor 
                classpath. (templated)
            driver_class_path: str, additional, driver-specific, classpath 
                settings. (templated)
            java_class: str, the main class of the Java application
            packages: str, comma-separated list of maven coordinates of  jars to 
                include on the driver and executor classpaths. (templated)
            exclude_packages: str, comma-separated list of maven coordinates 
                of jars to exclude while resolving the dependencies provided in 
                &#39;packages&#39; (templated)
            repositories: str, comma-separated list of additional remote repositories 
                to search for the maven coordinates given with &#39;packages&#39;
            total_executor_cores: int, (Standalone &amp; Mesos only) total cores for all 
                executors (Default: all the available cores on the worker)
            executor_cores: int (Standalone &amp; YARN only) Number of cores 
                per executor (Default: 2)
            executor_memory: str, memory per executor 
                (e.g. 1000M, 2G) (Default: 1G)
            driver_memory: str, memory allocated to the driver 
                (e.g. 1000M, 2G) (Default: 1G)
            keytab: str, full path to the file that contains the keytab (templated)
            principal: str, the name of the kerberos principal used 
                for keytab (templated)
            proxy_user: str, user to impersonate when submitting the 
                application (templated)
            name: str, name of the job (default airflow-spark). (templated)
            num_executors: int, number of executors to launch
            application_args: list, arguments for the application being 
                submitted (templated)
            env_vars: dict, environment variables for spark-submit. It supports 
                yarn and k8s mode too. (templated)
            verbose: bool, whether to pass the verbose flag to spark-submit process 
                for debugging
            spark_binary: str, the command to use for spark submit.
                                 Some distros may use spark2-submit.

    &#34;&#34;&#34;

    @apply_defaults
    def __init__(self,
                 application,
                 conf={},
                 conn_id=Setting.SPARK_CONFIG_SUBMIT_DEFAULT,
                 files=None,
                 py_files=None,
                 archives=None,
                 driver_class_path=None,
                 jars=None,
                 java_class=None,
                 packages=None,
                 exclude_packages=None,
                 repositories=None,
                 total_executor_cores=None,
                 executor_cores=None,
                 executor_memory=None,
                 driver_memory=None,
                 keytab=None,
                 principal=None,
                 proxy_user=None,
                 name=&#39;zuka_etl_spark&#39;,
                 num_executors=None,
                 application_args=None,
                 env_vars=None,
                 verbose=False,
                 spark_binary=&#34;spark-submit&#34;,
                 *args,
                 **kwargs):
        hook = BaseHook.get_connection(conn_id=conn_id)
        name = name if name.strip() != &#34;&#34; else hook.get_app_name()
        cf_json = hook.extra_dejson
        spark_cf = cf_json.get(&#34;conf&#34;, conf)
        if isinstance(conf, dict) and conf:
            for k, v in conf.items():
                logger.info(&#34;Update spark_conf with %s: %s&#34; % (k, v))
                spark_cf.update(k, v)

        if env_vars is None:
            env_vars = cf_json.get(&#34;env_vars&#34;, {})

        super(SparkSubmitOperator, self).__init__(
            application=application,
            conf=spark_cf,
            conn_id=conn_id,
            files=files,
            py_files=py_files,
            archives=archives,
            driver_class_path=driver_class_path,
            jars=jars,
            java_class=java_class,
            packages=packages,
            exclude_packages=exclude_packages,
            repositories=repositories,
            total_executor_cores=total_executor_cores,
            executor_cores=executor_cores,
            executor_memory=executor_memory,
            driver_memory=driver_memory,
            keytab=keytab,
            principal=principal,
            proxy_user=proxy_user,
            name=name,
            num_executors=num_executors,
            application_args=application_args,
            env_vars=env_vars,
            verbose=verbose,
            spark_binary=spark_binary,
            *args,
            **kwargs
        )

    def execute_env_vars(self, env_vars={}):
        import os
        try:
            for k, v in env_vars.items():
                logger.info(&#39;SET VARIABLE: %s:%s&#39; % (k, v))
                os.environ[k] = v
        except BaseException as e:
            logger.info(&#34;Cannot import variable spark because:\n%s&#34; % self.syslog.print_traceback())

    def execute(self, context):
        self.execute_env_vars(env_vars=self._env_vars)
        return super(SparkSubmitOperator, self).execute(context)


class SynTriggerDagRunOperator(BaseOperator):
    @apply_defaults
    def __init__(
            self,
            trigger_dag_id,
            python_callable=None,
            execution_date=None,
            scan_interval=20,
            *args, **kwargs):
        super(SynTriggerDagRunOperator, self).__init__(*args, **kwargs)
        self.python_callable = python_callable
        self.trigger_dag_id = trigger_dag_id
        self.scan_interval = scan_interval if scan_interval &gt; 0 else 20
        if isinstance(execution_date, datetime.datetime):
            self.execution_date = execution_date.isoformat()
        elif isinstance(execution_date, six.string_types):
            self.execution_date = execution_date
        elif execution_date is None:
            self.execution_date = execution_date
        else:
            raise TypeError(
                &#39;Expected str or datetime.datetime type &#39;
                &#39;for execution_date. Got {}&#39;.format(
                    type(execution_date)))

    def execute(self, context):
        time_start = time.time()
        if self.execution_date is not None:
            run_id = &#39;trig__{}&#39;.format(self.execution_date)
            self.execution_date = timezone.parse(self.execution_date)
        else:
            run_id = &#39;trig__&#39; + timezone.utcnow().isoformat()
        dro = DagRunOrder(run_id=run_id)
        if self.python_callable is not None:
            dro = self.python_callable(context, dro)
        if dro:
            trigger_dag(dag_id=self.trigger_dag_id,
                        run_id=dro.run_id,
                        conf=json.dumps(dro.payload),
                        execution_date=self.execution_date,
                        replace_microseconds=False)
            dag_run = list(DagRun.find(run_id=run_id))
            dag_run = dag_run[0] if dag_run else None
            count = 0
            logger.info(&#34;Start wait dag: %s complete. Run_id is: %s. Execution_date: %s&#34; % (
                self.trigger_dag_id, dro.run_id, self.execution_date))
            while dag_run is None or dag_run.get_state().lower().strip() == &#39;running&#39;:
                if count % 10 == 0:
                    logger.info(&#34;Still waiting...&#34;)
                    if dag_run is not None:
                        logger.info(dag_run.get_state())
                count += 1
                time.sleep(self.scan_interval)
                dag_run = list(DagRun.find(run_id=run_id))
                dag_run = dag_run[0] if dag_run else None
                time_run = time.time() - time_start
                if self.execution_timeout is not None and datetime.timedelta(seconds=time_run) &gt; self.execution_timeout:
                    logger.error(&#34;Timeout exception...&#34;)
                    raise AirflowTaskTimeout
            if dag_run.get_state() == &#39;failed&#39;:
                logger.error(&#34;Dag:%s failed...&#34; % (self.trigger_dag_id))
                raise AirflowException
            return 0
        else:
            self.log.info(&#34;Criteria not met, moving on&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="zuka_etl.custom.operator.EtlOperator"><code class="flex name class">
<span>class <span class="ident">EtlOperator</span></span>
<span>(</span><span>extract, transform=None, load=None, extract_kwargs=None, provide_context=False, templates_dict=None, templates_exts=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Process ETL pipeline</p>
<pre><code>Example:

    def ex(pipeline):
        pipeline.logger.info("This is extract function")
        pipeline.set_shipper("a", "11")
        return 1

    def transform(pipeline, value):
        pipeline.logger.info("This is transform function")
        print(value)
        return value

    def load(pipeline, value):
        pipeline.logger.info("This is load function")
        print(value)
        pipeline.logger.info(pipeline.get_shipper("a"))
        # save every thing you want

    EtlOperator(
        task_id="phong",
        extract=ex,
        transform=tras,
        load=load
    )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EtlOperator(PythonOperator):
    &#34;&#34;&#34;
    Process ETL pipeline

        Example:

            def ex(pipeline):
                pipeline.logger.info(&#34;This is extract function&#34;)
                pipeline.set_shipper(&#34;a&#34;, &#34;11&#34;)
                return 1

            def transform(pipeline, value):
                pipeline.logger.info(&#34;This is transform function&#34;)
                print(value)
                return value

            def load(pipeline, value):
                pipeline.logger.info(&#34;This is load function&#34;)
                print(value)
                pipeline.logger.info(pipeline.get_shipper(&#34;a&#34;))
                # save every thing you want

            EtlOperator(
                task_id=&#34;phong&#34;,
                extract=ex,
                transform=tras,
                load=load
            )
    &#34;&#34;&#34;

    @apply_defaults
    def __init__(
            self,
            extract,  # type: Callable
            transform=None,  # type: Callable
            load=None,  # type: Callable
            extract_kwargs=None,  # type: Optional[Dict]
            provide_context=False,  # type: bool
            templates_dict=None,  # type: Optional[Dict]
            templates_exts=None,  # type: Optional[Iterable[str]]
            *args,
            **kwargs
    ):
        super(EtlOperator, self).__init__(
            python_callable=extract,
            op_args=None,
            op_kwargs=None,
            provide_context=provide_context,
            templates_dict=templates_dict,
            templates_exts=templates_exts, *args, **kwargs)
        self.python_callable_object = self.build_pipeline(task_id=self.task_id,
                                                          extract=extract,
                                                          transform=transform,
                                                          load=load, additional_args=None,
                                                          additional_kwargs=extract_kwargs).run

    @staticmethod
    def build_pipeline(task_id, extract, transform, load, additional_args, additional_kwargs):
        return Process(task_id, extract=extract, transform=transform, load=load, additional_args=additional_args,
                       additional_kwargs=additional_kwargs)

    def execute(self, context):
        self.python_callable_object.dag_context = context
        self.python_callable = self.python_callable_object.run
        super(EtlOperator, self).execute(context=context)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>airflow.operators.python_operator.PythonOperator</li>
<li>airflow.models.baseoperator.BaseOperator</li>
<li>airflow.utils.log.logging_mixin.LoggingMixin</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="zuka_etl.custom.operator.EtlOperator.build_pipeline"><code class="name flex">
<span>def <span class="ident">build_pipeline</span></span>(<span>task_id, extract, transform, load, additional_args, additional_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_pipeline(task_id, extract, transform, load, additional_args, additional_kwargs):
    return Process(task_id, extract=extract, transform=transform, load=load, additional_args=additional_args,
                   additional_kwargs=additional_kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="zuka_etl.custom.operator.EtlOperator.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the main method to derive when creating an operator.
Context is the same dictionary used as when rendering jinja templates.</p>
<p>Refer to get_template_context for more context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    self.python_callable_object.dag_context = context
    self.python_callable = self.python_callable_object.run
    super(EtlOperator, self).execute(context=context)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="zuka_etl.custom.operator.SparkSubmitOperator"><code class="flex name class">
<span>class <span class="ident">SparkSubmitOperator</span></span>
<span>(</span><span>application, conf={}, conn_id='spark_connection_default_submit', files=None, py_files=None, archives=None, driver_class_path=None, jars=None, java_class=None, packages=None, exclude_packages=None, repositories=None, total_executor_cores=None, executor_cores=None, executor_memory=None, driver_memory=None, keytab=None, principal=None, proxy_user=None, name='zuka_etl_spark', num_executors=None, application_args=None, env_vars=None, verbose=False, spark_binary='spark-submit', *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Process Submit</p>
<pre><code>Example:
    from zuka_etl.custom.operator import SparkSubmitOperator

    ZukaSubmitOperator(
        task_id="phong",
        java_class = "",
        application = "/home/projects/job.jar",
        dag = dag_config
    )
</code></pre>
<p>This hook is a wrapper around the SparkSubmitOperator to kick off a spark-submit job.
It requires that the "spark-submit" binary is in the PATH or the spark-home is set
in the extra on the connection.</p>
<pre><code>Parameters:
    application: str, the application that submitted as a job,  either jar or 
        py file. (templated)
    conf: dict, arbitrary Spark configuration properties (templated)            
    conn_id: str, the connection id as configured in Airflow  administration. 
        When an invalid connection_id  is supplied, it will default to yarn.
    files: str, upload additional files to the executor running the job, 
        separated by a comma. Files will be placed in the working directory 
        of each executor.
            For example, serialized objects. (templated)
    py_files: str, additional python files used by the job, can be .zip, .egg 
        or .py. (templated)
    jars: str, submit additional jars to upload and place them in executor 
        classpath. (templated)
    driver_class_path: str, additional, driver-specific, classpath 
        settings. (templated)
    java_class: str, the main class of the Java application
    packages: str, comma-separated list of maven coordinates of  jars to 
        include on the driver and executor classpaths. (templated)
    exclude_packages: str, comma-separated list of maven coordinates 
        of jars to exclude while resolving the dependencies provided in 
        'packages' (templated)
    repositories: str, comma-separated list of additional remote repositories 
        to search for the maven coordinates given with 'packages'
    total_executor_cores: int, (Standalone &amp; Mesos only) total cores for all 
        executors (Default: all the available cores on the worker)
    executor_cores: int (Standalone &amp; YARN only) Number of cores 
        per executor (Default: 2)
    executor_memory: str, memory per executor 
        (e.g. 1000M, 2G) (Default: 1G)
    driver_memory: str, memory allocated to the driver 
        (e.g. 1000M, 2G) (Default: 1G)
    keytab: str, full path to the file that contains the keytab (templated)
    principal: str, the name of the kerberos principal used 
        for keytab (templated)
    proxy_user: str, user to impersonate when submitting the 
        application (templated)
    name: str, name of the job (default airflow-spark). (templated)
    num_executors: int, number of executors to launch
    application_args: list, arguments for the application being 
        submitted (templated)
    env_vars: dict, environment variables for spark-submit. It supports 
        yarn and k8s mode too. (templated)
    verbose: bool, whether to pass the verbose flag to spark-submit process 
        for debugging
    spark_binary: str, the command to use for spark submit.
                         Some distros may use spark2-submit.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SparkSubmitOperator(SparkSubmitOperator):
    &#34;&#34;&#34;
    Process Submit

        Example:
            from zuka_etl.custom.operator import SparkSubmitOperator

            ZukaSubmitOperator(
                task_id=&#34;phong&#34;,
                java_class = &#34;&#34;,
                application = &#34;/home/projects/job.jar&#34;,
                dag = dag_config
            )

    This hook is a wrapper around the SparkSubmitOperator to kick off a spark-submit job.
    It requires that the &#34;spark-submit&#34; binary is in the PATH or the spark-home is set
    in the extra on the connection.

        Parameters:
            application: str, the application that submitted as a job,  either jar or 
                py file. (templated)
            conf: dict, arbitrary Spark configuration properties (templated)            
            conn_id: str, the connection id as configured in Airflow  administration. 
                When an invalid connection_id  is supplied, it will default to yarn.
            files: str, upload additional files to the executor running the job, 
                separated by a comma. Files will be placed in the working directory 
                of each executor.
                    For example, serialized objects. (templated)
            py_files: str, additional python files used by the job, can be .zip, .egg 
                or .py. (templated)
            jars: str, submit additional jars to upload and place them in executor 
                classpath. (templated)
            driver_class_path: str, additional, driver-specific, classpath 
                settings. (templated)
            java_class: str, the main class of the Java application
            packages: str, comma-separated list of maven coordinates of  jars to 
                include on the driver and executor classpaths. (templated)
            exclude_packages: str, comma-separated list of maven coordinates 
                of jars to exclude while resolving the dependencies provided in 
                &#39;packages&#39; (templated)
            repositories: str, comma-separated list of additional remote repositories 
                to search for the maven coordinates given with &#39;packages&#39;
            total_executor_cores: int, (Standalone &amp; Mesos only) total cores for all 
                executors (Default: all the available cores on the worker)
            executor_cores: int (Standalone &amp; YARN only) Number of cores 
                per executor (Default: 2)
            executor_memory: str, memory per executor 
                (e.g. 1000M, 2G) (Default: 1G)
            driver_memory: str, memory allocated to the driver 
                (e.g. 1000M, 2G) (Default: 1G)
            keytab: str, full path to the file that contains the keytab (templated)
            principal: str, the name of the kerberos principal used 
                for keytab (templated)
            proxy_user: str, user to impersonate when submitting the 
                application (templated)
            name: str, name of the job (default airflow-spark). (templated)
            num_executors: int, number of executors to launch
            application_args: list, arguments for the application being 
                submitted (templated)
            env_vars: dict, environment variables for spark-submit. It supports 
                yarn and k8s mode too. (templated)
            verbose: bool, whether to pass the verbose flag to spark-submit process 
                for debugging
            spark_binary: str, the command to use for spark submit.
                                 Some distros may use spark2-submit.

    &#34;&#34;&#34;

    @apply_defaults
    def __init__(self,
                 application,
                 conf={},
                 conn_id=Setting.SPARK_CONFIG_SUBMIT_DEFAULT,
                 files=None,
                 py_files=None,
                 archives=None,
                 driver_class_path=None,
                 jars=None,
                 java_class=None,
                 packages=None,
                 exclude_packages=None,
                 repositories=None,
                 total_executor_cores=None,
                 executor_cores=None,
                 executor_memory=None,
                 driver_memory=None,
                 keytab=None,
                 principal=None,
                 proxy_user=None,
                 name=&#39;zuka_etl_spark&#39;,
                 num_executors=None,
                 application_args=None,
                 env_vars=None,
                 verbose=False,
                 spark_binary=&#34;spark-submit&#34;,
                 *args,
                 **kwargs):
        hook = BaseHook.get_connection(conn_id=conn_id)
        name = name if name.strip() != &#34;&#34; else hook.get_app_name()
        cf_json = hook.extra_dejson
        spark_cf = cf_json.get(&#34;conf&#34;, conf)
        if isinstance(conf, dict) and conf:
            for k, v in conf.items():
                logger.info(&#34;Update spark_conf with %s: %s&#34; % (k, v))
                spark_cf.update(k, v)

        if env_vars is None:
            env_vars = cf_json.get(&#34;env_vars&#34;, {})

        super(SparkSubmitOperator, self).__init__(
            application=application,
            conf=spark_cf,
            conn_id=conn_id,
            files=files,
            py_files=py_files,
            archives=archives,
            driver_class_path=driver_class_path,
            jars=jars,
            java_class=java_class,
            packages=packages,
            exclude_packages=exclude_packages,
            repositories=repositories,
            total_executor_cores=total_executor_cores,
            executor_cores=executor_cores,
            executor_memory=executor_memory,
            driver_memory=driver_memory,
            keytab=keytab,
            principal=principal,
            proxy_user=proxy_user,
            name=name,
            num_executors=num_executors,
            application_args=application_args,
            env_vars=env_vars,
            verbose=verbose,
            spark_binary=spark_binary,
            *args,
            **kwargs
        )

    def execute_env_vars(self, env_vars={}):
        import os
        try:
            for k, v in env_vars.items():
                logger.info(&#39;SET VARIABLE: %s:%s&#39; % (k, v))
                os.environ[k] = v
        except BaseException as e:
            logger.info(&#34;Cannot import variable spark because:\n%s&#34; % self.syslog.print_traceback())

    def execute(self, context):
        self.execute_env_vars(env_vars=self._env_vars)
        return super(SparkSubmitOperator, self).execute(context)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>airflow.contrib.operators.spark_submit_operator.SparkSubmitOperator</li>
<li>airflow.models.baseoperator.BaseOperator</li>
<li>airflow.utils.log.logging_mixin.LoggingMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="zuka_etl.custom.operator.SparkSubmitOperator.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Call the SparkSubmitHook to run the provided spark job</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    self.execute_env_vars(env_vars=self._env_vars)
    return super(SparkSubmitOperator, self).execute(context)</code></pre>
</details>
</dd>
<dt id="zuka_etl.custom.operator.SparkSubmitOperator.execute_env_vars"><code class="name flex">
<span>def <span class="ident">execute_env_vars</span></span>(<span>self, env_vars={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_env_vars(self, env_vars={}):
    import os
    try:
        for k, v in env_vars.items():
            logger.info(&#39;SET VARIABLE: %s:%s&#39; % (k, v))
            os.environ[k] = v
    except BaseException as e:
        logger.info(&#34;Cannot import variable spark because:\n%s&#34; % self.syslog.print_traceback())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="zuka_etl.custom.operator.SynTriggerDagRunOperator"><code class="flex name class">
<span>class <span class="ident">SynTriggerDagRunOperator</span></span>
<span>(</span><span>trigger_dag_id, python_callable=None, execution_date=None, scan_interval=20, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for all operators. Since operators create objects that
become nodes in the dag, BaseOperator contains many recursive methods for
dag crawling behavior. To derive this class, you are expected to override
the constructor as well as the 'execute' method.</p>
<p>Operators derived from this class should perform or trigger certain tasks
synchronously (wait for completion). Example of operators could be an
operator that runs a Pig job (PigOperator), a sensor operator that
waits for a partition to land in Hive (HiveSensorOperator), or one that
moves data from Hive to MySQL (Hive2MySqlOperator). Instances of these
operators (tasks) target specific operations, running specific scripts,
functions or data transfers.</p>
<p>This class is abstract and shouldn't be instantiated. Instantiating a
class derived from this one results in the creation of a task object,
which ultimately becomes a node in DAG objects. Task dependencies should
be set by using the set_upstream and/or set_downstream methods.</p>
<p>:param task_id: a unique, meaningful id for the task
:type task_id: str
:param owner: the owner of the task, using the unix username is recommended
:type owner: str
:param email: the 'to' email address(es) used in email alerts. This can be a
single email or multiple ones. Multiple addresses can be specified as a
comma or semi-colon separated string or by passing a list of strings.
:type email: str or list[str]
:param email_on_retry: Indicates whether email alerts should be sent when a
task is retried
:type email_on_retry: bool
:param email_on_failure: Indicates whether email alerts should be sent when
a task failed
:type email_on_failure: bool
:param retries: the number of retries that should be performed before
failing the task
:type retries: int
:param retry_delay: delay between retries
:type retry_delay: datetime.timedelta
:param retry_exponential_backoff: allow progressive longer waits between
retries by using exponential backoff algorithm on retry delay (delay
will be converted into seconds)
:type retry_exponential_backoff: bool
:param max_retry_delay: maximum delay interval between retries
:type max_retry_delay: datetime.timedelta
:param start_date: The <code>start_date</code> for the task, determines
the <code>execution_date</code> for the first task instance. The best practice
is to have the start_date rounded
to your DAG's <code>schedule_interval</code>. Daily jobs have their start_date
some day at 00:00:00, hourly jobs have their start_date at 00:00
of a specific hour. Note that Airflow simply looks at the latest
<code>execution_date</code> and adds the <code>schedule_interval</code> to determine
the next <code>execution_date</code>. It is also very important
to note that different tasks' dependencies
need to line up in time. If task A depends on task B and their
start_date are offset in a way that their execution_date don't line
up, A's dependencies will never be met. If you are looking to delay
a task, for example running a daily task at 2AM, look into the
<code>TimeSensor</code> and <code>TimeDeltaSensor</code>. We advise against using
dynamic <code>start_date</code> and recommend using fixed ones. Read the
FAQ entry about start_date for more information.
:type start_date: datetime.datetime
:param end_date: if specified, the scheduler won't go beyond this date
:type end_date: datetime.datetime
:param depends_on_past: when set to true, task instances will run
sequentially while relying on the previous task's schedule to
succeed. The task instance for the start_date is allowed to run.
:type depends_on_past: bool
:param wait_for_downstream: when set to true, an instance of task
X will wait for tasks immediately downstream of the previous instance
of task X to finish successfully before it runs. This is useful if the
different instances of a task X alter the same asset, and this asset
is used by tasks downstream of task X. Note that depends_on_past
is forced to True wherever wait_for_downstream is used. Also note that
only tasks <em>immediately</em> downstream of the previous task instance are waited
for; the statuses of any tasks further downstream are ignored.
:type wait_for_downstream: bool
:param dag: a reference to the dag the task is attached to (if any)
:type dag: airflow.models.DAG
:param priority_weight: priority weight of this task against other task.
This allows the executor to trigger higher priority tasks before
others when things get backed up. Set priority_weight as a higher
number for more important tasks.
:type priority_weight: int
:param weight_rule: weighting method used for the effective total
priority weight of the task. Options are:
<code>{ downstream | upstream | absolute }</code> default is <code>downstream</code>
When set to <code>downstream</code> the effective weight of the task is the
aggregate sum of all downstream descendants. As a result, upstream
tasks will have higher weight and will be scheduled more aggressively
when using positive weight values. This is useful when you have
multiple dag run instances and desire to have all upstream tasks to
complete for all runs before each dag can continue processing
downstream tasks. When set to <code>upstream</code> the effective weight is the
aggregate sum of all upstream ancestors. This is the opposite where
downtream tasks have higher weight and will be scheduled more
aggressively when using positive weight values. This is useful when you
have multiple dag run instances and prefer to have each dag complete
before starting upstream tasks of other dags.
When set to
<code>absolute</code>, the effective weight is the exact <code>priority_weight</code>
specified without additional weighting. You may want to do this when
you know exactly what priority weight each task should have.
Additionally, when set to <code>absolute</code>, there is bonus effect of
significantly speeding up the task creation process as for very large
DAGS. Options can be set as string or using the constants defined in
the static class <code>airflow.utils.WeightRule</code>
:type weight_rule: str
:param queue: which queue to target when running this job. Not
all executors implement queue management, the CeleryExecutor
does support targeting specific queues.
:type queue: str
:param pool: the slot pool this task should run in, slot pools are a
way to limit concurrency for certain tasks
:type pool: str
:param pool_slots: the number of pool slots this task should use (&gt;= 1)
Values less than 1 are not allowed.
:type pool_slots: int
:param sla: time by which the job is expected to succeed. Note that
this represents the <code>timedelta</code> after the period is closed. For
example if you set an SLA of 1 hour, the scheduler would send an email
soon after 1:00AM on the <code>2016-01-02</code> if the <code>2016-01-01</code> instance
has not succeeded yet.
The scheduler pays special attention for jobs with an SLA and
sends alert
emails for sla misses. SLA misses are also recorded in the database
for future reference. All tasks that share the same SLA time
get bundled in a single email, sent soon after that time. SLA
notification are sent once and only once for each task instance.
:type sla: datetime.timedelta
:param execution_timeout: max time allowed for the execution of
this task instance, if it goes beyond it will raise and fail.
:type execution_timeout: datetime.timedelta
:param on_failure_callback: a function to be called when a task instance
of this task fails. a context dictionary is passed as a single
parameter to this function. Context contains references to related
objects to the task instance and is documented under the macros
section of the API.
:type on_failure_callback: callable
:param on_retry_callback: much like the <code>on_failure_callback</code> except
that it is executed when retries occur.
:type on_retry_callback: callable
:param on_success_callback: much like the <code>on_failure_callback</code> except
that it is executed when the task succeeds.
:type on_success_callback: callable
:param trigger_rule: defines the rule by which dependencies are applied
for the task to get triggered. Options are:
<code>{ all_success | all_failed | all_done | one_success |
one_failed | none_failed | none_failed_or_skipped | none_skipped | dummy}</code>
default is <code>all_success</code>. Options can be set as string or
using the constants defined in the static class
<code>airflow.utils.TriggerRule</code>
:type trigger_rule: str
:param resources: A map of resource parameter names (the argument names of the
Resources constructor) to their values.
:type resources: dict
:param run_as_user: unix username to impersonate while running the task
:type run_as_user: str
:param task_concurrency: When set, a task will be able to limit the concurrent
runs across execution_dates
:type task_concurrency: int
:param executor_config: Additional task-level configuration parameters that are
interpreted by a specific executor. Parameters are namespaced by the name of
executor.</p>
<pre><code>**Example**: to run this task in a specific docker container through
the KubernetesExecutor ::

    MyOperator(...,
        executor_config={
        "KubernetesExecutor":
            {"image": "myCustomDockerImage"}
            }
    )
</code></pre>
<p>:type executor_config: dict
:param do_xcom_push: if True, an XCom is pushed containing the Operator's
result
:type do_xcom_push: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SynTriggerDagRunOperator(BaseOperator):
    @apply_defaults
    def __init__(
            self,
            trigger_dag_id,
            python_callable=None,
            execution_date=None,
            scan_interval=20,
            *args, **kwargs):
        super(SynTriggerDagRunOperator, self).__init__(*args, **kwargs)
        self.python_callable = python_callable
        self.trigger_dag_id = trigger_dag_id
        self.scan_interval = scan_interval if scan_interval &gt; 0 else 20
        if isinstance(execution_date, datetime.datetime):
            self.execution_date = execution_date.isoformat()
        elif isinstance(execution_date, six.string_types):
            self.execution_date = execution_date
        elif execution_date is None:
            self.execution_date = execution_date
        else:
            raise TypeError(
                &#39;Expected str or datetime.datetime type &#39;
                &#39;for execution_date. Got {}&#39;.format(
                    type(execution_date)))

    def execute(self, context):
        time_start = time.time()
        if self.execution_date is not None:
            run_id = &#39;trig__{}&#39;.format(self.execution_date)
            self.execution_date = timezone.parse(self.execution_date)
        else:
            run_id = &#39;trig__&#39; + timezone.utcnow().isoformat()
        dro = DagRunOrder(run_id=run_id)
        if self.python_callable is not None:
            dro = self.python_callable(context, dro)
        if dro:
            trigger_dag(dag_id=self.trigger_dag_id,
                        run_id=dro.run_id,
                        conf=json.dumps(dro.payload),
                        execution_date=self.execution_date,
                        replace_microseconds=False)
            dag_run = list(DagRun.find(run_id=run_id))
            dag_run = dag_run[0] if dag_run else None
            count = 0
            logger.info(&#34;Start wait dag: %s complete. Run_id is: %s. Execution_date: %s&#34; % (
                self.trigger_dag_id, dro.run_id, self.execution_date))
            while dag_run is None or dag_run.get_state().lower().strip() == &#39;running&#39;:
                if count % 10 == 0:
                    logger.info(&#34;Still waiting...&#34;)
                    if dag_run is not None:
                        logger.info(dag_run.get_state())
                count += 1
                time.sleep(self.scan_interval)
                dag_run = list(DagRun.find(run_id=run_id))
                dag_run = dag_run[0] if dag_run else None
                time_run = time.time() - time_start
                if self.execution_timeout is not None and datetime.timedelta(seconds=time_run) &gt; self.execution_timeout:
                    logger.error(&#34;Timeout exception...&#34;)
                    raise AirflowTaskTimeout
            if dag_run.get_state() == &#39;failed&#39;:
                logger.error(&#34;Dag:%s failed...&#34; % (self.trigger_dag_id))
                raise AirflowException
            return 0
        else:
            self.log.info(&#34;Criteria not met, moving on&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>airflow.models.baseoperator.BaseOperator</li>
<li>airflow.utils.log.logging_mixin.LoggingMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="zuka_etl.custom.operator.SynTriggerDagRunOperator.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the main method to derive when creating an operator.
Context is the same dictionary used as when rendering jinja templates.</p>
<p>Refer to get_template_context for more context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, context):
    time_start = time.time()
    if self.execution_date is not None:
        run_id = &#39;trig__{}&#39;.format(self.execution_date)
        self.execution_date = timezone.parse(self.execution_date)
    else:
        run_id = &#39;trig__&#39; + timezone.utcnow().isoformat()
    dro = DagRunOrder(run_id=run_id)
    if self.python_callable is not None:
        dro = self.python_callable(context, dro)
    if dro:
        trigger_dag(dag_id=self.trigger_dag_id,
                    run_id=dro.run_id,
                    conf=json.dumps(dro.payload),
                    execution_date=self.execution_date,
                    replace_microseconds=False)
        dag_run = list(DagRun.find(run_id=run_id))
        dag_run = dag_run[0] if dag_run else None
        count = 0
        logger.info(&#34;Start wait dag: %s complete. Run_id is: %s. Execution_date: %s&#34; % (
            self.trigger_dag_id, dro.run_id, self.execution_date))
        while dag_run is None or dag_run.get_state().lower().strip() == &#39;running&#39;:
            if count % 10 == 0:
                logger.info(&#34;Still waiting...&#34;)
                if dag_run is not None:
                    logger.info(dag_run.get_state())
            count += 1
            time.sleep(self.scan_interval)
            dag_run = list(DagRun.find(run_id=run_id))
            dag_run = dag_run[0] if dag_run else None
            time_run = time.time() - time_start
            if self.execution_timeout is not None and datetime.timedelta(seconds=time_run) &gt; self.execution_timeout:
                logger.error(&#34;Timeout exception...&#34;)
                raise AirflowTaskTimeout
        if dag_run.get_state() == &#39;failed&#39;:
            logger.error(&#34;Dag:%s failed...&#34; % (self.trigger_dag_id))
            raise AirflowException
        return 0
    else:
        self.log.info(&#34;Criteria not met, moving on&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="zuka_etl.custom" href="index.html">zuka_etl.custom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="zuka_etl.custom.operator.EtlOperator" href="#zuka_etl.custom.operator.EtlOperator">EtlOperator</a></code></h4>
<ul class="">
<li><code><a title="zuka_etl.custom.operator.EtlOperator.build_pipeline" href="#zuka_etl.custom.operator.EtlOperator.build_pipeline">build_pipeline</a></code></li>
<li><code><a title="zuka_etl.custom.operator.EtlOperator.execute" href="#zuka_etl.custom.operator.EtlOperator.execute">execute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="zuka_etl.custom.operator.SparkSubmitOperator" href="#zuka_etl.custom.operator.SparkSubmitOperator">SparkSubmitOperator</a></code></h4>
<ul class="">
<li><code><a title="zuka_etl.custom.operator.SparkSubmitOperator.execute" href="#zuka_etl.custom.operator.SparkSubmitOperator.execute">execute</a></code></li>
<li><code><a title="zuka_etl.custom.operator.SparkSubmitOperator.execute_env_vars" href="#zuka_etl.custom.operator.SparkSubmitOperator.execute_env_vars">execute_env_vars</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="zuka_etl.custom.operator.SynTriggerDagRunOperator" href="#zuka_etl.custom.operator.SynTriggerDagRunOperator">SynTriggerDagRunOperator</a></code></h4>
<ul class="">
<li><code><a title="zuka_etl.custom.operator.SynTriggerDagRunOperator.execute" href="#zuka_etl.custom.operator.SynTriggerDagRunOperator.execute">execute</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>